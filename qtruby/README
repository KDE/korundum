/***************************************************************************
 * 	(C) 2003 Richard Dale All rights reserved.                             *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as               *
 *   published by the Free Software Foundation; either version 2 of the    *
 *   License, or (at your option) any later version.                       *
 *                                                                         *
 ***************************************************************************/

Here is a Ruby SMOKE adaptor for Qt

Why ruby? From the rubytalk list

On 8/28/03 8:56 PM, "Scott Thompson" wrote:

>> : Can anyone give me a good reason why I would want to use Ruby over
>> Python?
>> 
>> Ruby smells better than Python.  Also, it has cuter girls.
>> 
>> Python sometimes tastes better if you prepare it right.
> 
> I hadn't noticed the odor thing.  It does have a faintly floral aroma
> doesn't it.
> 
> Of course it is no surprise that you can get more and cuter girls with
> Rubies than you can with Pythons.
> 
> Scott

So there you have it! :)

Here is 'Hello World' in QtRuby:

#!/usr/bin/ruby -w

require 'Qt'

a = Qt::Application.new(ARGV)
hello = Qt::PushButton.new("Hello World!", nil)
hello.resize(100, 30)
a.setMainWidget(hello)
hello.show()
a.exec()

Ruby 1.8 is unfortunately implicitly required as with 1.6.x it is not possible to:

   Make dynamic constants available (thus forcing syntax such as Qt.RichText rather than Qt::RichText)<br>
   Call super in the initialize method thus making subclassing of non trivial classes impossible

QtRuby features a very complete coverage of the Qt api:

	- You can call all Qt public and protected methods, and all friend methods
		such as bitBlt() etc
		
	- Virtual methods
		All virtual methods can be overriden, not just event handlers
		
	- Properties 
		'foobar = 5' is a synonym for 'setFooBar(5)'
		
	- Operator overloading
		The full range of Qt operator methods is available, for example:
		
			p1 = Qt::Point.new(5,5)   => (5, 5)
			p2 = Qt::Point.new(20,20) => (20, 20)
			p1 + p2                   => (25, 25)
			
	- Declare signals and slots
	 	Signals and slots are declared as list of strings like this:
		
			slots 'setColor(QColor)', 'slotLoad(const QString&)'..
			signals 'clicked()'..
			
		Currently C++ type signatures must be used, a future version of QtRuby
			will allow ruby type signatures instead.
		
		Connect slots and signals like this:
					
			Qt::Object.connect( @_colormenu, SIGNAL( "activated( int )" ),
						 		self, SLOT( "slotColorMenu( int )" ) )
	
		And emit signals like this:
		
			emit colorChanged( black )

	- Constructors
		You can call constructors in the conventional style:
		
		    quit = Qt::PushButton.new("Quit", self, "quit")
			
		Or you can pass a block if you prefer:
		
			w = MyWidget.new { setCaption("foobar") }
			
		The block will be called in the context of the newly created instance.
		
		Ordinary arguments can be provided as well as a block at the end:
			
			w = MyWidget.new(nil) { setCaption("foobar") }
			
		They are run in the context of the new instance.
		
		And there's more! You can also pass an arg to the block, and it will
			be run in the context of the arg:
			
			w = MyWidget.new { |theWidget| theWidget.setCaption "foobar" }
			
	- Use Qt Designer
		A 'rbuic' tool is included in qtruby/rubylib/designer/rbuic to compile
			.ui files into ruby code.
			
	- QtRuby shell
		You can use the QtRuby shell in bin/rbqtsh to create widgets 
			interactively from the command line.
			
	- API reference
		Use the bin/rbqtapish tool to discover which methods are available in
			the QtRuby api.
			
	- Example programs
		The best way to start programming QtRuby is to look at some existing
			code and start messing with it.. 
		The are various samples under qtruby/rubylib/examples.

Have Fun!

-- Richard
