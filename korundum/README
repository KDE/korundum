Please see kdebindings/qtruby/README

KDE Specific Infomation:

	- Instead of require 'Qt', use require 'Korundum' for KDE programs. 
	
	- The KDE K* classes such as KApplication are renamed as KDE::Application. 
	  The other KDE classes are in the KParts::, KIO:: or DOM:: namespaces,
	  with the same names as their C++ counterparts. 

	- DCOP Support. Here is a minimal ruby dcop slot implementation:
	
			require 'Korundum'
			
			class MyWidget < KDE::PushButton
				k_dcop 'QPoint mySlot(int,QString)'
	
				def initialize(parent, name)
					super
				end
			
				def mySlot(counter,greeting)
					return Qt::Point.new(50, 100)
				end
			end

		This slot is passed an integer and a string, and returns a Qt::Point.
		
		Note that the class doesn't have to inherit from DCOPObject. If you
		  include a 'k_dcop' slots declaration a 'listener' dcop object 
		  instance is created automatically.
	
	- Define a dcop slot like this in one ruby program:

	    k_dcop 'QPoint getPoint(QString)'

	    def getPoint(msg)
		puts "message: #{msg}"
		return Qt::Point.new(50, 100)
	    end

	- Call it from another program and print the reply, like this:

	    dcopRef = KDE::DCOPRef.new("dcopslot", "MyWidget")
	    res = dcopRef.call("QPoint getPoint(QString)", "Hello from dcopsend")
	    puts "result class: #{res.class.name} x: #{res.x} y: #{res.y}"

	- Send to a DCOPRef is similar:
	    
	    dcopRef = KDE::DCOPRef.new("dcopslot", "MyWidget")
	    dcopRef.send("mySlot(QString)", "Hello from dcopsend")
	
	-  Note that the full type signature of the target dcop slot must be
	   specified at present.	
	  
	- DCOP Signals are defined like this:
	
	    k_dcop_signals 'void testEmitSignal(QString)'
		
	    def doit()
	        puts "In doit.."
	        emit testEmitSignal("Hello DCOP Slot")
	    end
	  	  
	- Connect slot 'mySlot' to a DCOP signal like this:
	
	    res = slottest.connectDCOPSignal("dcopsignal", "SenderWidget", 
		                                 "testEmitSignal(QString)", "mySlot(QString)", 
										 true)

	- Use the '-kde' option with the rbuic tool to require the 'Korundum' 
		extension rather than the 'Qt' one. If the '-x' option is used in 
		conjunction, it generates a KDE top level. For example:
		
		$ rbuic -x -kde knotifywidgetbase.ui -o knotifywidgetbase.rb

		Will generate this top level code:

			if $0 == __FILE__
    			about = KDE::AboutData.new("knotifywidgetbase", "KNotifyWidgetBase", "0.1")
    			KDE::CmdLineArgs.init(ARGV, about)
    			a = KDE::Application.new()
    			w = KNotifyWidgetBase.new
    			a.setMainWidget(w)
    			w.show
    			a.exec
			end
